# -*- coding: utf-8 -*-
"""
Created on Thu Mar 23 08:07:32 2023

@author: alevesque
"""

from __future__ import annotations
import time
import asyncio
import warnings
from binance_trader_class_def_unicorn_multilogging import BinanceTraderWIP, BinanceWs
import config
import nest_asyncio
with warnings.catch_warnings():
    warnings.simplefilter('ignore', RuntimeWarning)


async def main() -> None:
    
    autotrader = BinanceTraderWIP(intervs=[interv for interv in config.intervals])
    
    while True:  # continue running contents as long as no KeyboardInterrupt
        # start time of loop, so can reconnect before server ~24h timeout
        start_time = time.time()
        # connect to exchange server, setup websockets, trade manager, client
        await autotrader.initialize_trade_engine()
        
        try:
            # if it has been more than x hours, restart loop to reconnect
            # and avoid server timeout
            while time.time() < start_time+3600*20:
                await autotrader.kl_socket.run()
                # print(autotrader.kl_socket.bal_update_flag)
                # if autotrader.kl_socket.bal_update_flag == True:
                    # print('0')
                
                orders = await autotrader.trading_strategy(autotrader.kl_socket.indicators, autotrader.kl_socket.data)
              
                if orders:
                    order_result = {}
                    for trading_pair in orders:
                        # autotrader.balance = autotrader.kl_socket.balance
                        order_result[trading_pair] = orders[trading_pair].order
                        order_result[trading_pair]['status'] = None
                        if orders[trading_pair].order['side'] in ['BUY', 'SELL']:# and orders[trading_pair].alive():
                            # print('3')
                            if autotrader.kl_socket.bal_update_flag[trading_pair] == True:
                                autotrader.kl_socket.current_pair_buffer.append(trading_pair)
                                order_result[trading_pair] = await autotrader.place_order(**orders[trading_pair].order)
                                autotrader.kl_socket.bal_update_flag[trading_pair] = False
                            # print('4')
                            if order_result[trading_pair]:
                                # print(order_result[trading_pair])
                                orders[trading_pair].order['status'] = order_result[trading_pair]['status']
                            else:
                                print('Error placing order.')
                                '''
                                # TODO: DO WE ACTUALLY CARE ABOUT PARTIAL ORDERS? - NOT REALLY
                                if orders[trading_pair].alive():
                                    order_result_raw = await autotrader._server_connect_try_except('a', {}, {'a': order_response.recv()})
                                    #if update is from order execution, log response (dont care about other account updates on this stream)
                                    if order_result_raw['e'] == 'executionReport':
                                        order_result = autotrader._order_stream_data_process(order_result_raw, datastream='Type2')
                                        if order_result:
                                            order.order['status'] = order_result['status']
                                        else:
                                            continue
                                        last_order_status = order_result['status']
                                '''
                        # else:
                            # order_result[trading_pair]['status'] = None
                        
                    # if (await autotrader._balance_update() == False):
                        # print('balance update false')
                    autotrader.log_data(autotrader.kl_socket.indicators, order_result)
        except KeyboardInterrupt:  # if Ctrl+C or IDE stopped - doesn't seem to trigger if program is interrupted in a sub task
            print('Program interrupted.')
            return
        except RuntimeError:
            print('Runtime error.')
        except asyncio.CancelledError:  # triggers in linux not windows
            print('Program cancelled.')
            return
        finally:
            await autotrader.async_client.close_connection()


if __name__ == "__main__":
    nest_asyncio.apply()  # allows async functions to run in an IDE IPython console
    loop = asyncio.get_event_loop()  # create main asynchronous loop
    try:
        asyncio.run(main())  # run main()
    except KeyboardInterrupt:  # if program stopped via IDE or Ctrl+C - triggers if program interrupted in sub task but not if in main loop
        print('Keyboard Interrupt')
    except RuntimeError:
        print('runtime error')
    finally:
        # close out pending asynchronous tasks
        print('Find all running tasks')
        pending = asyncio.all_tasks(loop=loop)
        for task in pending:
            print(task.get_name())
            task.cancel()
        # all tasks closed, now stop loop and exit
        if loop.is_running():
            print('stop loop')
            loop.stop()
        print('Program stopped - exiting.')
